<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>WebCrypto KEX Playground</title>
  </head>

  <body>
    <main>
      <section>
        <h2>ECDH</h2>
        <section class="ecdh">
          <h2>Alice's Keys</h2>
          <textarea class="private-key-alice" rows="7" cols="68"></textarea>
          <textarea class="public-key-alice" rows="7" cols="68"></textarea><br/>
          <div class="fingerprint-alice"></div>

          <h2>Bob's Keys</h2>
          <textarea class="private-key-bob" rows="7" cols="68"></textarea>
          <textarea class="public-key-bob" rows="7" cols="68"></textarea><br/>
          <div class="fingerprint-bob"></div>

          <input class="derive-bits-button" type="button" value="Calculate ECDH Shared Group" /><br/>

          <h2>Raw ECDH Bytes</h2>
          <textarea class="derived-bits" rows="2" cols="68"></textarea><br/>

          <h2>HKDF Enhanced Bytes</h2>
          <textarea class="hkdf-bits" rows="2" cols="68"></textarea><br/>
        </section>
      </section>
    </main>

    <script>
      (() => {
        async function deriveSharedSecret(privateKey, publicKey) {
          const derivedSecretBits = await window.crypto.subtle.deriveBits(
            { name: "ECDH", namedCurve: "P-384", public: publicKey },
            privateKey,
            // Needs to match the key length, officially this API is supposed
            // to support a value of 'null' here if you want the full non-truncated
            // version but that doesn't seem supported at least on Firefox
            //
            // Refer to Step 11 under the Derive Bits operation here: https://w3c.github.io/webcrypto/#ecdh-operations
            384
          );

          const derivedBits = document.querySelector('.ecdh .derived-bits');
          derivedBits.value = btoa(String.fromCharCode(...new Uint8Array(derivedSecretBits)));

          let derivedKeyData = await window.crypto.subtle.importKey(
            'raw', derivedSecretBits, 'HKDF', true, ['deriveBits']
          );

          const hkdf_in = new Uint8Array(8);
          await window.crypto.getRandomValues(hkdf_in);

          const infoStr = "fixed-data-todo";
          const infoBytes = new Uint8Array([...infoStr].map(char => char.charCodeAt(0)));

          const hkdfEnhancedBits = await window.crypto.subtle.deriveBits(
            { name: 'HKDF', hash: 'SHA-256', salt: hkdf_in, info: infoBytes },
            derivedKeyData,
            256
          );

          const hkdfSalt = btoa(String.fromCharCode(...hkdf_in));
          const hkdfBits = btoa(String.fromCharCode(...new Uint8Array(hkdfEnhancedBits)));

          const hkdfBitField = document.querySelector('.ecdh .hkdf-bits');
          hkdfBitField.value = `${hkdfSalt}.${hkdfBits}`;

          return [hkdf_in, hkdfEnhancedBits];
        }

        async function fingerprint(publicKey) {
          const publicKeyData = await window.crypto.subtle.exportKey('raw', publicKey);
          const publicKeyBytes = new Uint8Array(publicKeyData);

          // Create compressed point
          const compressedPoint = new Uint8Array(49);

          let x = publicKeyBytes.slice(1, 49);
          let y = publicKeyBytes.slice(49);

          // first byte is 0x02 or 0x03 depending on the parity of the
          // y-coordinate, followed by the x coordinate. We can't technically
          // figure out whether the y-coodinate is odd without doing big number
          // arithmetic, but this is a fair approximation.
          compressedPoint[0] = (y[y.length - 1] % 2) === 0 ? 0x02 : 0x03;
          compressedPoint.set(x, 1);

          const hash = await window.crypto.subtle.digest('SHA-1', compressedPoint);
          const hashArray = Array.from(new Uint8Array(hash));
          const fingerprint = hashArray.map(b => b.toString(16).padStart(2, '0')).join(':');

          return fingerprint;
        }

        async function generateKey() {
          return await window.crypto.subtle.generateKey(
            { name: 'ECDH', namedCurve: 'P-384' },
            true,
            ['deriveBits']
          );
        }

        async function loadKey(privateKeyContents, publicKeyContents) {
            const pkcs8ByteString = atob(pemUnwrap(privateKeyContents));
            const privateKeyBytes = new Uint8Array([...pkcs8ByteString].map(char => char.charCodeAt(0)));
            const privateKey = await window.crypto.subtle.importKey(
              'pkcs8', privateKeyBytes.buffer, 'ECDH', true, ['deriveBits']
            );

            const spkiByteString = atob(pemUnwrap(publicKeyContents));
            const publicKeyBytes = new Uint8Array([...spkiByteString].map(char => char.charCodeAt(0)));
            const publicKey = await window.crypto.subtle.importKey(
              'spki', publicKeyBytes.buffer, 'ECDH', true, ['deriveBits']
            );

            return { privateKey, publicKey };
        }

        async function generateOrReadKey(id) {
          const privateKeyForm = document.querySelector(`.ecdh .private-key-${id}`);
          const publicKeyForm = document.querySelector(`.ecdh .public-key-${id}`);

          if (privateKeyForm.value.trim() === '' || publicKeyForm.value.trim() === '') {
            const newKey = await generateKey();

            const pkcs8ByteString = await window.crypto.subtle.exportKey('pkcs8', newKey.privateKey);
            const pkcs8Content = btoa(String.fromCharCode(...new Uint8Array(pkcs8ByteString)));
            privateKeyForm.value = pemWrap('PRIVATE KEY', pkcs8Content);

            const spkiByteString = await window.crypto.subtle.exportKey('spki', newKey.publicKey);
            const spkiContent = btoa(String.fromCharCode(...new Uint8Array(spkiByteString)));
            publicKeyForm.value = pemWrap('PUBLIC KEY', spkiContent);

            return newKey;
          } else {
            return loadKey(privateKeyForm.value, publicKeyForm.value);
          }
        }

        function pemWrap(header, data) {
          const chunkSize = 64;

          let base64Chunks = [];
          let startIndex = 0;

          base64Chunks.push(`-----BEGIN ${header}-----`);

          while (startIndex < data.length) {
            base64Chunks.push(data.substr(startIndex, chunkSize));
            startIndex += chunkSize;
          }

          base64Chunks.push(`-----END ${header}-----`);

          return base64Chunks.join("\n");
        }

        function pemUnwrap(data) {
          let allBase64Chunks = data.trim().split("\n");
          let relevantBase64Chunks = allBase64Chunks.slice(1, allBase64Chunks.length - 1);
          return relevantBase64Chunks.join('');
        }

        const generateAlicesKeyPair = generateOrReadKey('alice');
        const generateBobsKeyPair = generateOrReadKey('bob');

        Promise.all([generateAlicesKeyPair, generateBobsKeyPair])
          .then(values => {
            const alicesKeyPair = values[0];
            const bobsKeyPair = values[1];

            fingerprint(alicesKeyPair.publicKey)
              .then(fp => {
                const aliceFP = document.querySelector(".ecdh .fingerprint-alice");
                aliceFP.textContent = fp;
              });

            fingerprint(bobsKeyPair.publicKey)
              .then(fp => {
                const bobFP = document.querySelector(".ecdh .fingerprint-bob");
                bobFP.textContent = fp;
              });

            const deriveBitsButton = document.querySelector(".ecdh .derive-bits-button");
            deriveBitsButton.addEventListener("click", () => {
              deriveSharedSecret(alicesKeyPair.privateKey, bobsKeyPair.publicKey);
            });
          });
      })();
    </script>
  </body>
</html>
