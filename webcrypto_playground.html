<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>WebCrypto KEX Playground</title>
  </head>

  <body>
    <main>
      <section>
        <h2>ECDH</h2>
        <section class="ecdh">
          <h2>Alice's Keys</h2>
          <textarea class="private-key-alice" rows="7" cols="100"></textarea><br/>
          <textarea class="public-key-alice" rows="6" cols="100"></textarea><br/>

          <h2>Bob's Keys</h2>
          <textarea class="private-key-bob" rows="7" cols="100"></textarea>
          <textarea class="public-key-bob" rows="6" cols="100"></textarea><br/>

          <h2>Raw ECDH Bytes</h2>
          <textarea class="derived-bits" rows="2" cols="100"></textarea><br/>
          <input class="derive-bits-button" type="button" value="Calculate ECDH Shared Group" /><br/>
        </section>
      </section>
    </main>

    <script>
      (() => {
        async function deriveSharedSecret(privateKey, publicKey) {
          const derivedSecretBits = await window.crypto.subtle.deriveBits(
            { name: "ECDH", namedCurve: "P-384", public: publicKey },
            privateKey,
            // Needs to match the key length, officially this API is supposed
            // to support a value of 'null' here if you want the full non-truncated
            // version but that doesn't seem supported at least on Firefox
            //
            // Refer to Step 11 under the Derive Bits operation here: https://w3c.github.io/webcrypto/#ecdh-operations
            384
          );

          const sharedSecretForm = document.querySelector('.ecdh .derived-bits');
          sharedSecretForm.value = btoa(String.fromCharCode(...new Uint8Array(derivedSecretBits)));
        }

        function pemFormat(header, data) {
          const chunkSize = 64;

          let base64Chunks = [];
          let startIndex = 0;

          base64Chunks.push(`-----BEGIN ${header}-----`);

          while (startIndex < data.length) {
            base64Chunks.push(data.substr(startIndex, chunkSize));
            startIndex += chunkSize;
          }

          base64Chunks.push(`-----END ${header}-----`);

          return base64Chunks.join("\n");
        }

        function pemUnformat(data) {
          let allBase64Chunks = data.split("\n");
          let relevantBase64Chunks = allBase64Chunks.slice(1, allBase64Chunks.length - 1);
          return relevantBase64Chunks.join('');
        }

        async function generateOrReadKey(id) {
          const privateKeyForm = document.querySelector(`.ecdh .private-key-${id}`);
          const publicKeyForm = document.querySelector(`.ecdh .public-key-${id}`);

          if (privateKeyForm.value === '' || publicKeyForm.value === '') {
            const newKey = await window.crypto.subtle.generateKey(
              { name: 'ECDH', namedCurve: 'P-384' },
              true,
              ['deriveBits']
            );

            const pkcs8ByteString = await window.crypto.subtle.exportKey('pkcs8', newKey.privateKey);
            const pkcs8Content = btoa(String.fromCharCode(...new Uint8Array(pkcs8ByteString)));
            privateKeyForm.value = pemFormat('PRIVATE KEY', pkcs8Content);

            const spkiByteString = await window.crypto.subtle.exportKey('spki', newKey.publicKey);
            const spkiContent = btoa(String.fromCharCode(...new Uint8Array(spkiByteString)));
            publicKeyForm.value = pemFormat('PUBLIC KEY', spkiContent);

            return newKey;
          } else {

            const pkcs8ByteString = atob(pemUnformat(privateKeyForm.value));
            const privateKeyBytes = new Uint8Array([...pkcs8ByteString].map(char => char.charCodeAt(0)));
            const privateKey = await window.crypto.subtle.importKey(
              'pkcs8', privateKeyBytes.buffer, 'ECDH', true, ['deriveBits']
            );

            const spkiByteString = atob(pemUnformat(publicKeyForm.value));
            const publicKeyBytes = new Uint8Array([...spkiByteString].map(char => char.charCodeAt(0)));
            const publicKey = await window.crypto.subtle.importKey(
              'spki', publicKeyBytes.buffer, 'ECDH', true, ['deriveBits']
            );

            return { privateKey, publicKey };
          }
        }

        const generateAlicesKeyPair = generateOrReadKey('alice');
        const generateBobsKeyPair = generateOrReadKey('bob');

        Promise.all([generateAlicesKeyPair, generateBobsKeyPair])
          .then(values => {
            const alicesKeyPair = values[0];
            const bobsKeyPair = values[1];

            const deriveBitsButton = document.querySelector(".ecdh .derive-bits-button");
            deriveBitsButton.addEventListener("click", () => {
              // Alice then generates a secret using her private key and Bob's public key.
              // Bob could generate the same secret using his private key and Alice's public key.
              deriveSharedSecret(alicesKeyPair.privateKey, bobsKeyPair.publicKey);
            });
          });

      })();
    </script>
  </body>
</html>
